Pour cette semaine, on passe en revue les résultats pour les programmes à 2 classes.

Complexité :
- aspect combinatoire

Pour D : 5% de gènes avec que des zéros
Pour C : 16%
Pour B : 32%

--> Calculer le nombre combinatoire de solutions pour chaque problème en fonction du nombre de zéros et le relier au temps d'exécution
--> Mettre en rapport le nombre combinatoire de solutions, le nombre de gènes à zéro et le temps d'exécution

Jeu de données complet pour calculer le nombre de gènes à zéro (savoir si ça a réellement un impact) = PKN_TE_bin_mtx_with_annotations.csv

selgene = gène sélectionné
affinity = les matchs entre cellules
On pourrait utiliser une table de hachage pour lire plus facilement les identifiants des gènes lors des tests

Ligne 14, 26 : consomme beaucoup de mémoire (count)
La présence de {} (énumération) dans le corps (body) des prédicats consomme bcp de mémoire.
Utiliser gringo (->grounded) sur un fichier test pour analyser la consommation mémoire.
v10.2: la suppression des redondances n'utilise plus d'énumération.
Accolades dans la tête d'un prédicat = guessing -> plongement dans l'espace des solutions (ex: ligne 30, générer 0 ou 1 apparition de tous les éléments parmi 10 = 2^10) -> 1 seul guessing dans v10.2
Maximize : récupérère l'optimal dans l'ensemble des answer sets qui ont été générés et filtrés par des contraintes

1. Essayer de résoudre le problème à n-classes en partant du programme v10.2 sans regarder la solution.
2. Imaginons que le programme à n-classes fonctionne --> comment gérer les redondances à ce niveau-là ? Trouver un critère équivalent à la maximisation des readouts mais à n-classes --> rechercher consensus (utiliser les données de umap : une trace pour chaque branche ?) pour que les n-classes maintiennent la cellule dans la même trajectoire.

Travailler sur les matrices qui commencent par 2023_